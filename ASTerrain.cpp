
/*
******************************************************************
* ASTerrain.cpp
*******************************************************************
* Implement all methods prototyped in ASTerrain.h
*******************************************************************
*/

#include "ASTerrain.h"

/*
*******************************************************************
* Constructor
*******************************************************************
* Set all member values for the player object so we know our 
* player (hero) has some sort of value!
*/

ASTerrain::ASTerrain()
{
	m_height      = 0;
	m_width       = 0;
	m_numIndices  = 0;
	m_numVertices = 0;
	m_iBuffer     = 0;
	m_vBuffer     = 0;
	m_heightMap   = 0;
	m_texture     = 0;
	m_vertices    = 0;
}

/*
*******************************************************************
* Empty consturctor
*******************************************************************
*/

ASTerrain::ASTerrain(const ASTerrain&)
{}

/*
*******************************************************************
* Destructor
*******************************************************************
*/

ASTerrain::~ASTerrain()
{}

/*
*******************************************************************
* METHOD: Init
*******************************************************************
* Initialise the terrain objects by setting default values for
* the size of the plane, this method will also call private 
* interface for initialising the index and vertex buffers
*
* @param ID3D11Device* - Pointer to the rendering device
* @param char*         - Pointer to the heightmap bitmap file
* @return bool - True if successfully intiialised, else false
*/

bool ASTerrain::Init(ID3D11Device* device, char* heightmapFile, WCHAR* texFile)
{
	// Attempt to load the heightmap and then normalise its vector
	// so it can be passed to the geometry buffers
	bool success = LoadHeightMap(heightmapFile);
	if(!success)
		return false;
	else
		NormaliseHeightMap();

	// Calculate the normals for the terrain data and store them
	// in the ASLightVertex struct to be passed to the rendering pipeline
	success = CalculateMapNormals();
	if(!success)
		return false;

	// Populate the class struct with information on where the texture should be mapped to
	CalculateTextureCoords();

	// Load the texture to be applied to the map, only once the texture coordinates
	// have been mapped to the global struct
	success = LoadTexture(device, texFile);
	if(!success)
		return false;

	// Initialise the buffers through the private interface, return the callback
	// to check if initialisation succeeced 
	return InitBuffers(device);
}

/*
*******************************************************************
* METHOD: Load Height Map
*******************************************************************
* Loads the bitmap file and converts the pixel data into a heightmap
* array.  The array is generated by determining the intensity at each
* index to determine how high that point is, values from 0 to 1 range
* from the 0-255 value on the RGB scale.
*
* @param char* - pointer to the bitmap file
* @return bool - True if successfully loaded, else false
*/

bool ASTerrain::LoadHeightMap(char* mapFile)
{
	FILE* readFile;
	unsigned int count; // unsigned as this num could be large dependent on input size
	BITMAPFILEHEADER bmpFileHeader;
	BITMAPINFOHEADER bmpInfoHeader;
	unsigned char* bmpImg;
	unsigned char  height;
	int size;
	int imageSize;
	int err = 0;

	// Open the height map file and read its contents into a char array
	err = fopen_s(&readFile, mapFile, "rb");
	if(err != 0)
		return false;

	count = fread(&bmpFileHeader, sizeof(BITMAPFILEHEADER), 1, readFile);
	if(count != 1)
		return false;

	count = fread(&bmpInfoHeader, sizeof(BITMAPINFOHEADER), 1, readFile);
	if(count != 1)
		return false;

	// Save the dimensions of the terrain from the heightmap and then calculate
	// the how the map is to be translated to the world
	m_width  = bmpInfoHeader.biWidth;
	m_height = bmpInfoHeader.biHeight;

	imageSize = m_width * m_height * 3; // multiply by three as a bmp image has 3 channels but we only need one

	// Set the char array to store all information on the input image
	bmpImg = new unsigned char[imageSize];
	if(!bmpImg)
		return false;

	// Start reading from the start of the input file and then close the file pointer
	fseek(readFile, bmpFileHeader.bfOffBits, SEEK_SET);
	count = fread(bmpImg, 1, imageSize, readFile);
	if(count != imageSize)
		return false;
	err = fclose(readFile);
	if(err != 0)
		return false;

	// Populate the ASHeightMap struct with file info
	m_heightMap = new ASHeightMap[m_width * m_height];
	if(!m_heightMap)
		return false;

	int currIndex = 0;
	int mapIndex  = 0;

	for(unsigned int j = 0; j < m_height; j++)
	{
		for(unsigned int i = 0; i < m_width; i++)
		{
			height   = bmpImg[currIndex];
			mapIndex = (m_height * j) + i;

			m_heightMap[mapIndex].pos = D3DXVECTOR3(
													 (float)i,
													 (float)height,	// y offset is now the calculated height based on intensity from
																	// the input image
													 (float)j
												   );

			// Start processing the vertex (skip g,b channels for this pixel)
			currIndex += 3;
		}
	}

	// Release temp buffers
	delete [] bmpImg;
	bmpImg  = 0;

	return true;
}

/*
*******************************************************************
* METHOD: Init Buffers
*******************************************************************
* Initialises the index and vertex buffers for the terrain
*
* @param ID3D11Device* - Pointer to the rendering device
* @return bool - True if successfully intiialised, else false
*/

bool ASTerrain::InitBuffers(ID3D11Device* device)
{
	// Position of the terrain in 3D space
	float posX = 0;
	float posZ = 0;
	float texU = 0;
	float texV = 0;

	// Get the number of vertices and indices for the mesh, -1 from each
	// height and width because C++ is 0 indexed, then * 6 to the total
	// (two triangles per quad)
	m_numVertices = (m_width - 1) * (m_height - 1) * 6;

	// Create the veritce and indice arrays to populate buffers
	m_vertices = new ASVertex[m_numVertices];
	if(!m_vertices)
		return false;

	// 
	int currIndex = 0;

	// Populate the vertice and indice arrays with information for the terrain
	for(int j = 0; j < (m_height - 1); j++)
	{
		for(int i = 0; i < (m_width - 1); i++)
		{
			// Vertices for each point of the quad
			int botL = (m_height * j) + i;
			int botR = (m_height * j) + (i + 1);
			int topL = (m_height * (j + 1)) + i;
			int topR = (m_height * (j + 1)) + (i + 1);

			// Build the triangles inside the quad

			// Top left
			// set the texV coord to cover the top edge of the texture
			texV = m_heightMap[topL].texCoord.y;
			if(texV == 1.0f)
				texV = 0.0f;
			m_vertices[currIndex].pos      = D3DXVECTOR3(m_heightMap[topL].pos.x, m_heightMap[topL].pos.y, m_heightMap[topL].pos.z);
			m_vertices[currIndex].texCoord = D3DXVECTOR2(m_heightMap[topL].texCoord.x, texV);
			m_vertices[currIndex].normal   = D3DXVECTOR3(m_heightMap[topL].normals.x, m_heightMap[topL].normals.y, m_heightMap[topL].normals.z);
			currIndex++;

			// Top right
			// set the tex coords to cover top and right edge
			texU = m_heightMap[topR].texCoord.x;
			texV = m_heightMap[topR].texCoord.y;
			if(texU == 1.0f)
				texU = 0.0f;
			if(texV == 1.0f)
				texV = 0.0f;

			m_vertices[currIndex].pos      = D3DXVECTOR3(m_heightMap[topR].pos.x, m_heightMap[topR].pos.y, m_heightMap[topR].pos.z);
			m_vertices[currIndex].texCoord = D3DXVECTOR2(texU, texV);
			m_vertices[currIndex].normal   = D3DXVECTOR3(m_heightMap[topR].normals.x, m_heightMap[topR].normals.y, m_heightMap[topR].normals.z);
			currIndex++;

			// Bottom left
			m_vertices[currIndex].pos      = D3DXVECTOR3(m_heightMap[botL].pos.x, m_heightMap[botL].pos.y, m_heightMap[botL].pos.z);
			m_vertices[currIndex].texCoord = D3DXVECTOR2(m_heightMap[botL].texCoord.x, m_heightMap[botL].texCoord.y);
			m_vertices[currIndex].normal   = D3DXVECTOR3(m_heightMap[botL].normals.x, m_heightMap[botL].normals.y, m_heightMap[botL].normals.z);
			currIndex++;

			// Bottom left
			m_vertices[currIndex].pos      = D3DXVECTOR3(m_heightMap[botL].pos.x, m_heightMap[botL].pos.y, m_heightMap[botL].pos.z);
			m_vertices[currIndex].texCoord = D3DXVECTOR2(m_heightMap[botL].texCoord.x, m_heightMap[botL].texCoord.y);
			m_vertices[currIndex].normal   = D3DXVECTOR3(m_heightMap[botL].normals.x, m_heightMap[botL].normals.y, m_heightMap[botL].normals.z);
			currIndex++;

			// Top right
			// set the tex coords to cover top and right edge
			texU = m_heightMap[topR].texCoord.x;
			texV = m_heightMap[topR].texCoord.y;
			if(texU == 1.0f)
				texU = 0.0f;
			if(texV == 1.0f)
				texV = 0.0f;

			m_vertices[currIndex].pos      = D3DXVECTOR3(m_heightMap[topR].pos.x, m_heightMap[topR].pos.y, m_heightMap[topR].pos.z);
			m_vertices[currIndex].texCoord = D3DXVECTOR2(texU, texV);
			m_vertices[currIndex].normal   = D3DXVECTOR3(m_heightMap[topR].normals.x, m_heightMap[topR].normals.y, m_heightMap[topR].normals.z);
			currIndex++;

			// Bottom right
			texU = m_heightMap[botR].texCoord.x;
			if(texU == 0.0f) 
				texU = 1.0f;
			m_vertices[currIndex].pos      = D3DXVECTOR3(m_heightMap[botR].pos.x, m_heightMap[botR].pos.y, m_heightMap[botR].pos.z);
			m_vertices[currIndex].texCoord = D3DXVECTOR2(texU, m_heightMap[botR].texCoord.y);
			m_vertices[currIndex].normal   = D3DXVECTOR3(m_heightMap[botR].normals.x, m_heightMap[botR].normals.y, m_heightMap[botR].normals.z);
			currIndex++;

		}
	}

	// Everything was successful
	return true;
}

/*
*******************************************************************
* METHOD: Get Texture
*******************************************************************
* Returns the current texture loaded for the map
*
* @return ID3D11ShaderResourceView* - pointer to the current texture
*/

ID3D11ShaderResourceView* ASTerrain::GetTexture()
{
	return m_texture->GetTexture();
}

/*
*******************************************************************
* METHOD: Calculate Texture Coords
*******************************************************************
* Calculates the texture coordinates for the terrain, this is done
* by utilising the TEXTURE_TILE_SIZE global to repeat the tile to
* ensure that qualit on the terrain is not lost, this is done by
* storing portions of the texture data into the height map array
*/

void ASTerrain::CalculateTextureCoords()
{
	// Calculate how many times the texture coords need to be incremented (on each pass
	// of the for loop, the increment value will be appended to texU and texV coords
	// and then added to the heightMap struct)
	float increment = (float)TEXTURE_TILE_SIZE / (float)m_width;
	
	// Textures are measured from 0.0f to 1.0f, this will keep track of that
	float texU = 0.0f;
	float texV = 1.0f;

	// Calculate how many times the textures needs to be repeated
	int texRepeat = m_width / TEXTURE_TILE_SIZE;

	// Variables to track the number of texU and texV coordinates found
	int texUCount = 0;
	int texVCount = 0;

	// Loop the height map and calculat the U, V coords for every vertex
	for(int j = 0; j < m_height; j++)
	{
		for(int i = 0; i < m_width; i++)
		{
			// populate the heightmap vertex with the coords - on first iteration map them
			// to the default texU and texV values, these will change as we increment through the
			// loop
			int currIndex = (m_height * j) + i;
			m_heightMap[currIndex].texCoord.x = texU;
			m_heightMap[currIndex].texCoord.y = texV;

			// Increment the texU coordinate by the increment amount determined earlier
			texU += increment;
			texUCount++;

			// Check if we have reached the end of the texture (textures range from 0.f to 1.f)
			if(texUCount == texRepeat) {
				texU = 0.0f;
				texUCount = 0;
			}
		}

		// Increment the tv coord 
		texV -= increment;
		texVCount++;

		// Check if we have reached the top of the texture, if so loop to the start
		if(texVCount == texRepeat) {
			texV = 1.0f;
			texVCount = 0;
		}
	}
}

/*
*******************************************************************
* METHOD: Load the map texture
*******************************************************************
* Loads the texture using the m_textures interface methods
*
* @return bool - True if successfully loaded, else false
*/

bool ASTerrain::LoadTexture(ID3D11Device* device, WCHAR* texFile)
{
	// Check we could create a texture object, then initialise it
	m_texture = new ASTexture;
	if(!m_texture)
		return false;
	if(!m_texture->Init(device, texFile))
		return false;

	return true;
}

/*
*******************************************************************
* METHOD: Calculate Map Normals
*******************************************************************
* Calculates the normals of each vertex in the terrains heightmap.
* normals are calculated by taking the average normals of each
* face in a vertex and then average that cumulative product to
* give the global illumination to the scene. 
*
* @return bool - True if successfully calculated, else false
*/

bool ASTerrain::CalculateMapNormals()
{
	// Temp vars to store information on vertexes
	D3DXVECTOR3 vertA;
	D3DXVECTOR3 vertB;
	D3DXVECTOR3 vertC;
	D3DXVECTOR3 vecA;
	D3DXVECTOR3 vecB;
	D3DXVECTOR3 normSum;
	
	float len;

	// Store un-normalised vectors in a temp array
	ASLightVector* normals = new ASLightVector[(m_height - 1) * (m_width - 1)];
	if(!normals)
		return false;

	// Loop through all faces in the mash and compute normals between them
	for(unsigned int j = 0; j < (m_height - 1); j++)
	{
		for(unsigned int i = 0; (i < m_width - 1); i++)
		{
			// Get the vertices that the current face is located at
			int vertIndexA = (j * m_height) + i;
			int vertIndexB = (j * m_height) + (i + 1);
			int vertIndexC = ((j + 1) * m_height) + i;

			// Extract the X, Y, Z components of each vertice in the face
			vertA = D3DXVECTOR3(m_heightMap[vertIndexA].pos.x, m_heightMap[vertIndexA].pos.y, m_heightMap[vertIndexA].pos.z);
			vertB = D3DXVECTOR3(m_heightMap[vertIndexB].pos.x, m_heightMap[vertIndexB].pos.y, m_heightMap[vertIndexB].pos.z);
			vertC = D3DXVECTOR3(m_heightMap[vertIndexC].pos.x, m_heightMap[vertIndexC].pos.y, m_heightMap[vertIndexC].pos.z);

			// Calculate the vectors for this face
			vecA = D3DXVECTOR3(vertA.x - vertC.x, vertA.y - vertC.y, vertA.z - vertC.z);
			vecB = D3DXVECTOR3(vertC.x - vertB.x, vertC.y - vertB.y, vertC.z - vertB.z);

			// Get the current face
			int currFace = (j * (m_height-1)) + i;

			normals[currFace].vn = D3DXVECTOR3((vecA.y * vecB.z) - (vecA.z * vecB.y),
											   (vecA.z * vecB.x) - (vecA.x * vecB.z),
											   (vecA.x * vecB.y) - (vecA.y * vecB.x));

		}
	}

	// Get the average of each face normal, calculated by testing if the vertex at
	// j,i touches its neighbouring vert
	for(int j = 0; j < m_height; j++)
	{
		for(int i = 0; i < m_width; i++)
		{
			// Keeps the total of the normals at each index, so we can calculate the cumulative average
			normSum = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

			// Set default values for indexes
			unsigned int count = 0;
			unsigned int currIndex = 0;

			// Bottom left face - ensure we are inside the bounds of the map
			if(((i-1) >= 0) && ((j-1) >= 0))
			{
				currIndex = ((j-1)*(m_height-1))+(i-1);

				normSum.x = normals[currIndex].vn.x;
				normSum.y = normals[currIndex].vn.y;
				normSum.z = normals[currIndex].vn.z;
				count++;
			}

			// Bottom right face
			if((i < (m_width-1)) && ((j-1) >= 0))
			{
				currIndex = ((j-1) * (m_height-1)) + i;

				normSum.x = normals[currIndex].vn.x;
				normSum.y = normals[currIndex].vn.y;
				normSum.z = normals[currIndex].vn.z;
				count++;
			}

			// Top left face
			if(((i - 1) >= 0) && (j < (m_height-1)))
			{
				currIndex = (j * (m_height-1)) + (i-1);

				normSum.x = normals[currIndex].vn.x;
				normSum.y = normals[currIndex].vn.y;
				normSum.z = normals[currIndex].vn.z;
				count++;
			}

			// Top right face
			if((i < (m_width-1)) && (j < (m_height-1)))
			{
				currIndex = (j * (m_height-1)) + i;

				normSum.x = normals[currIndex].vn.x;
				normSum.y = normals[currIndex].vn.y;
				normSum.z = normals[currIndex].vn.z;
				count++;
			}

			// Compute the average of the faces
			normSum.x = (normSum.x / (float)count);
			normSum.y = (normSum.y / (float)count);
			normSum.z = (normSum.z / (float)count);

			len = sqrt((normSum.x * normSum.x) + (normSum.y + normSum.y) + (normSum.z * normSum.z));
			currIndex = (j * m_height) + i;

			m_heightMap[currIndex].normals.x = normSum.x / len;
			m_heightMap[currIndex].normals.y = normSum.y / len;
			m_heightMap[currIndex].normals.z = normSum.z / len;
		}
	}

	// Dispose of local resources
	delete [] normals;
	normals = 0;
	
	return true;
}

/*
*******************************************************************
* METHOD: Normalise Height Map
*******************************************************************
* Normalises the vector populated in ASHeightMap so that we can
* pass it to the buffers for rendering
*/

void ASTerrain::NormaliseHeightMap()
{
	for(unsigned int j = 0; j < m_height; j++)
		for(unsigned int i = 0; i < m_width; i++)
			m_heightMap[(m_height * j) + i].pos.y /= 15.0f;
}

/*
*******************************************************************
* METHOD: Get Indices
*******************************************************************
* Returns the number of indices in the terrain mesh
*/

int ASTerrain::GetNumVertices()
{
	return m_numVertices;
}

/*
*******************************************************************
* METHOD: Get Vertice Array
*******************************************************************
* Returns a pointer to the vertex array populated in this class
*
* @param void* - A copy of the vertex list in this class
*/

void ASTerrain::GetVerticeArray(void* vOut)
{
	memcpy(vOut, m_vertices, sizeof(ASVertex) * m_numVertices);
}

/*
*******************************************************************
* METHOD: Release
*******************************************************************
* Release all items held by the class and set their pointers to 
* null
*/

void ASTerrain::Release()
{
	// Dispose of the height map
	if(m_heightMap)
	{
		delete [] m_heightMap;
		m_heightMap = 0;
	}
	// Dispose of texture 
	if(m_texture)
	{
		m_texture->Release();
		m_texture = 0;
	}
	// Release the vertice buffer
	if(m_vertices)
	{
		delete [] m_vertices;
		m_vertices = 0;
	}
}


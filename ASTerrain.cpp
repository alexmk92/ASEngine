
/*
******************************************************************
* ASTerrain.cpp
*******************************************************************
* Implement all methods prototyped in ASTerrain.h
*******************************************************************
*/

#include "ASTerrain.h"

/*
*******************************************************************
* Constructor
*******************************************************************
* Set all member values for the player object so we know our 
* player (hero) has some sort of value!
*/

ASTerrain::ASTerrain()
{
	m_height      = 0;
	m_width       = 0;
	m_numIndices  = 0;
	m_numVertices = 0;
	m_iBuffer     = 0;
	m_vBuffer     = 0;
	m_heightMap   = 0;
}

/*
*******************************************************************
* Empty consturctor
*******************************************************************
*/

ASTerrain::ASTerrain(const ASTerrain&)
{}

/*
*******************************************************************
* Destructor
*******************************************************************
*/

ASTerrain::~ASTerrain()
{}

/*
*******************************************************************
* METHOD: Init
*******************************************************************
* Initialise the terrain objects by setting default values for
* the size of the plane, this method will also call private 
* interface for initialising the index and vertex buffers
*
* @param ID3D11Device* - Pointer to the rendering device
* @param char*         - Pointer to the heightmap bitmap file
* @return bool - True if successfully intiialised, else false
*/

bool ASTerrain::Init(ID3D11Device* device, char* heightmapFile)
{
	// Width and height of the terrain (its a 2D plane across the Y axis)
	m_width  = 100;
	m_height = 100;

	// Attempt to load the heightmap and then normalise its vector
	// so it can be passed to the geometry buffers
	bool success = LoadHeightMap(heightmapFile);
	if(!success)
		return false;
	else
		NormaliseHeightMap();

	// Calculate the normals for the terrain data and store them
	// in the ASLightVertex struct to be passed to the rendering pipeline
	success = CalculateMapNormals();
	if(!success)
		return false;

	// Initialise the buffers through the private interface, return the callback
	// to check if initialisation succeeced 
	return InitBuffers(device);
}

/*
*******************************************************************
* METHOD: Load Height Map
*******************************************************************
* Loads the bitmap file and converts the pixel data into a heightmap
* array.  The array is generated by determining the intensity at each
* index to determine how high that point is, values from 0 to 1 range
* from the 0-255 value on the RGB scale.
*
* @param char* - pointer to the bitmap file
* @return bool - True if successfully loaded, else false
*/

bool ASTerrain::LoadHeightMap(char* mapFile)
{
	FILE* readFile;
	unsigned int count; // unsigned as this num could be large dependent on input size
	BITMAPFILEHEADER bmpFileHeader;
	BITMAPINFOHEADER bmpInfoHeader;
	unsigned char* bmpImg;
	unsigned char  height;
	int size;
	int imageSize;
	int err = 0;

	// Open the height map file and read its contents into a char array
	err = fopen_s(&readFile, mapFile, "rb");
	if(err != 0)
		return false;

	count = fread(&bmpFileHeader, sizeof(BITMAPFILEHEADER), 1, readFile);
	if(count != 1)
		return false;

	count = fread(&bmpInfoHeader, sizeof(BITMAPINFOHEADER), 1, readFile);
	if(count != 1)
		return false;

	// Save the dimensions of the terrain from the heightmap and then calculate
	// the how the map is to be translated to the world
	m_width  = bmpInfoHeader.biWidth;
	m_height = bmpInfoHeader.biHeight;

	imageSize = m_width * m_height * 3; // multiply by three as a bmp image has 3 channels but we only need one

	// Set the char array to store all information on the input image
	bmpImg = new unsigned char[imageSize];
	if(!bmpImg)
		return false;

	// Start reading from the start of the input file and then close the file pointer
	fseek(readFile, bmpFileHeader.bfOffBits, SEEK_SET);
	count = fread(bmpImg, 1, imageSize, readFile);
	if(count != imageSize)
		return false;
	err = fclose(readFile);
	if(err != 0)
		return false;

	// Populate the ASHeightMap struct with file info
	m_heightMap = new ASHeightMap[m_width * m_height];
	if(!m_heightMap)
		return false;

	int currIndex = 0;
	int mapIndex  = 0;

	for(unsigned int j = 0; j < m_height; j++)
	{
		for(unsigned int i = 0; i < m_width; i++)
		{
			height   = bmpImg[currIndex];
			mapIndex = (m_height * j) + i;

			m_heightMap[mapIndex].pos = D3DXVECTOR3(
													 (float)i,
													 (float)height,	// y offset is now the calculated height based on intensity from
																	// the input image
													 (float)j
												   );

			// Start processing the vertex (skip g,b channels for this pixel)
			currIndex += 3;
		}
	}

	// Release temp buffers
	delete [] bmpImg;
	bmpImg  = 0;

	return true;
}

/*
*******************************************************************
* METHOD: Init Buffers
*******************************************************************
* Initialises the index and vertex buffers for the terrain
*
* @param ID3D11Device* - Pointer to the rendering device
* @return bool - True if successfully intiialised, else false
*/

bool ASTerrain::InitBuffers(ID3D11Device* device)
{
	HRESULT hr;

	// Used to track the vertices and indices of the mesh
	ASVertex*      vertices;
	unsigned long* indices;

	// Position of the terrain in 3D space
	float posX = 0;
	float posZ = 0;

	// Buffers to be described to be sent to the rendering pipeline
	D3D11_BUFFER_DESC vBufferDesc;
	D3D11_BUFFER_DESC iBufferDesc;

	// Data to be sent to the rendering pipeline
	D3D11_SUBRESOURCE_DATA vData;
	D3D11_SUBRESOURCE_DATA iData;

	// Get the number of vertices and indices for the mesh, -1 from each
	// height and width because C++ is 0 indexed, then * 6 to the total
	// (two triangles per quad)
	m_numVertices = (m_width - 1) * (m_height - 1) * 6;
	m_numIndices  = m_numVertices;

	// Create the veritce and indice arrays to populate buffers
	vertices = new ASVertex[m_numVertices];
	if(!vertices)
		return false;

	// Use long instead of int as meshes can become very large
	indices = new unsigned long[m_numIndices];
	if(!indices)
		return false;

	// 
	int currIndex = 0;

	// Populate the vertice and indice arrays with information for the terrain
	for(int j = 0; j < (m_height - 1); j++)
	{
		for(int i = 0; i < (m_width - 1); i++)
		{
			// Vertices for each point of the quad
			int botL = (m_height * j) + i;
			int botR = (m_height * j) + (i + 1);
			int topL = (m_height * (j + 1)) + i;
			int topR = (m_height * (j + 1)) + (i + 1);

			// Build the triangles inside the quad
			// Top left
			vertices[currIndex].pos = D3DXVECTOR3(m_heightMap[topL].pos.x, m_heightMap[topL].pos.y, m_heightMap[topL].pos.z);
			vertices[currIndex].normal = D3DXVECTOR3(m_heightMap[topL].normals.x, m_heightMap[topL].normals.y, m_heightMap[topL].normals.z);
			indices[currIndex] = currIndex;
			currIndex++;

			// Top right
			vertices[currIndex].pos = D3DXVECTOR3(m_heightMap[topR].pos.x, m_heightMap[topR].pos.y, m_heightMap[topR].pos.z);
			vertices[currIndex].normal = D3DXVECTOR3(m_heightMap[topR].normals.x, m_heightMap[topR].normals.y, m_heightMap[topR].normals.z);
			indices[currIndex] = currIndex;
			currIndex++;

			// Bottom left
			vertices[currIndex].pos = D3DXVECTOR3(m_heightMap[botL].pos.x, m_heightMap[botL].pos.y, m_heightMap[botL].pos.z);
			vertices[currIndex].normal = D3DXVECTOR3(m_heightMap[botL].normals.x, m_heightMap[botL].normals.y, m_heightMap[botL].normals.z);
			indices[currIndex] = currIndex;
			currIndex++;

			// Bottom left
			vertices[currIndex].pos = D3DXVECTOR3(m_heightMap[botL].pos.x, m_heightMap[botL].pos.y, m_heightMap[botL].pos.z);
			vertices[currIndex].normal = D3DXVECTOR3(m_heightMap[botL].normals.x, m_heightMap[botL].normals.y, m_heightMap[botL].normals.z);
			indices[currIndex] = currIndex;
			currIndex++;

			// Bottom right
			vertices[currIndex].pos = D3DXVECTOR3(m_heightMap[topR].pos.x, m_heightMap[topR].pos.y, m_heightMap[topR].pos.z);
			vertices[currIndex].normal = D3DXVECTOR3(m_heightMap[topR].normals.x, m_heightMap[topR].normals.y, m_heightMap[topR].normals.z);
			indices[currIndex] = currIndex;
			currIndex++;

			// Bottom right
			vertices[currIndex].pos = D3DXVECTOR3(m_heightMap[botR].pos.x, m_heightMap[botR].pos.y, m_heightMap[botR].pos.z);
			vertices[currIndex].normal = D3DXVECTOR3(m_heightMap[botR].normals.x, m_heightMap[botR].normals.y, m_heightMap[botR].normals.z);
			indices[currIndex] = currIndex;
			currIndex++;

		}
	}

	// Describe the vertex and index arrays 
	vBufferDesc.Usage = D3D11_USAGE_DEFAULT;
	vBufferDesc.ByteWidth = sizeof(ASVertex) * m_numVertices;
	vBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	vBufferDesc.CPUAccessFlags = 0;
	vBufferDesc.MiscFlags = 0;
	vBufferDesc.StructureByteStride = 0;

	// Give the subresource structure a pointer to the vertex data, then create
	// the vertex buffer to be passed to the device
	vData.pSysMem = vertices;
	vData.SysMemPitch = 0;
	vData.SysMemSlicePitch = 0;

	hr = device->CreateBuffer(&vBufferDesc, &vData, &m_vBuffer);
	if(FAILED(hr))
		return false;

	// Describe the index buffer
	// Set up the description of the static index buffer.
	iBufferDesc.Usage = D3D11_USAGE_DEFAULT;
	iBufferDesc.ByteWidth = sizeof(unsigned long) * m_numIndices;
	iBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
	iBufferDesc.CPUAccessFlags = 0;
	iBufferDesc.MiscFlags = 0;
	iBufferDesc.StructureByteStride = 0;

	// Give the subresource structure a pointer to the index data, then create the
	// index buffer to be passed to the device
	iData.pSysMem = indices;
	iData.SysMemPitch = 0;
	iData.SysMemSlicePitch = 0;

	// Create the index buffer.
	hr = device->CreateBuffer(&iBufferDesc, &iData, &m_iBuffer);
	if(FAILED(hr))
		return false;

	// Release the local buffer descriptors
	delete [] vertices;
	delete [] indices;
	vertices = 0;
	indices  = 0;

	// Everything was successful
	return true;
}

/*
*******************************************************************
* METHOD: Calculate Map Normals
*******************************************************************
* Calculates the normals of each vertex in the terrains heightmap.
* normals are calculated by taking the average normals of each
* face in a vertex and then average that cumulative product to
* give the global illumination to the scene. 
*
* @return bool - True if successfully calculated, else false
*/

bool ASTerrain::CalculateMapNormals()
{
	// Temp vars to store information on vertexes
	D3DXVECTOR3 vertA;
	D3DXVECTOR3 vertB;
	D3DXVECTOR3 vertC;
	D3DXVECTOR3 vecA;
	D3DXVECTOR3 vecB;
	D3DXVECTOR3 normSum;
	
	float len;

	// Store un-normalised vectors in a temp array
	ASLightVector* normals = new ASLightVector[(m_height - 1) * (m_width - 1)];
	if(!normals)
		return false;

	// Loop through all faces in the mash and compute normals between them
	for(unsigned int j = 0; j < (m_height - 1); j++)
	{
		for(unsigned int i = 0; (i < m_width - 1); i++)
		{
			// Get the vertices that the current face is located at
			int vertIndexA = (j * m_height) + i;
			int vertIndexB = (j * m_height) + (i + 1);
			int vertIndexC = ((j + 1) * m_height) + i;

			// Extract the X, Y, Z components of each vertice in the face
			vertA = D3DXVECTOR3(m_heightMap[vertIndexA].pos.x, m_heightMap[vertIndexA].pos.y, m_heightMap[vertIndexA].pos.z);
			vertB = D3DXVECTOR3(m_heightMap[vertIndexB].pos.x, m_heightMap[vertIndexB].pos.y, m_heightMap[vertIndexB].pos.z);
			vertC = D3DXVECTOR3(m_heightMap[vertIndexC].pos.x, m_heightMap[vertIndexC].pos.y, m_heightMap[vertIndexC].pos.z);

			// Calculate the vectors for this face
			vecA = D3DXVECTOR3(vertA.x - vertC.x, vertA.y - vertC.y, vertA.z - vertC.z);
			vecB = D3DXVECTOR3(vertC.x - vertB.x, vertC.y - vertB.y, vertC.z - vertB.z);

			// Get the current face
			int currFace = (j * (m_height-1)) + i;

			normals[currFace].vn = D3DXVECTOR3((vecA.y * vecB.z) - (vecA.z * vecB.y),
											   (vecA.z * vecB.x) - (vecA.x * vecB.z),
											   (vecA.x * vecB.y) - (vecA.y * vecB.x));

		}
	}

	// Get the average of each face normal, calculated by testing if the vertex at
	// j,i touches its neighbouring vert
	for(int j = 0; j < m_height; j++)
	{
		for(int i = 0; i < m_width; i++)
		{
			// Keeps the total of the normals at each index, so we can calculate the cumulative average
			normSum = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

			// Set default values for indexes
			unsigned int count = 0;
			unsigned int currIndex = 0;

			// Bottom left face - ensure we are inside the bounds of the map
			if(((i-1) >= 0) && ((j-1) >= 0))
			{
				currIndex = ((j-1)*(m_height-1))+(i-1);

				normSum.x = normals[currIndex].vn.x;
				normSum.y = normals[currIndex].vn.y;
				normSum.z = normals[currIndex].vn.z;
				count++;
			}

			// Bottom right face
			if((i < (m_width-1)) && ((j-1) >= 0))
			{
				currIndex = ((j-1) * (m_height-1)) + i;

				normSum.x = normals[currIndex].vn.x;
				normSum.y = normals[currIndex].vn.y;
				normSum.z = normals[currIndex].vn.z;
				count++;
			}

			// Top left face
			if(((i - 1) >= 0) && (j < (m_height-1)))
			{
				currIndex = (j * (m_height-1)) + (i-1);

				normSum.x = normals[currIndex].vn.x;
				normSum.y = normals[currIndex].vn.y;
				normSum.z = normals[currIndex].vn.z;
				count++;
			}

			// Top right face
			if((i < (m_width-1)) && (j < (m_height-1)))
			{
				currIndex = (j * (m_height-1)) + i;

				normSum.x = normals[currIndex].vn.x;
				normSum.y = normals[currIndex].vn.y;
				normSum.z = normals[currIndex].vn.z;
				count++;
			}

			// Compute the average of the faces
			normSum.x = (normSum.x / (float)count);
			normSum.y = (normSum.y / (float)count);
			normSum.z = (normSum.z / (float)count);

			len = sqrt((normSum.x * normSum.x) + (normSum.y + normSum.y) + (normSum.z * normSum.z));
			currIndex = (j * m_height) + i;

			m_heightMap[currIndex].normals.x = normSum.x / len;
			m_heightMap[currIndex].normals.y = normSum.y / len;
			m_heightMap[currIndex].normals.z = normSum.z / len;
		}
	}

	// Dispose of local resources
	delete [] normals;
	normals = 0;
}

/*
*******************************************************************
* METHOD: Normalise Height Map
*******************************************************************
* Normalises the vector populated in ASHeightMap so that we can
* pass it to the buffers for rendering
*/

void ASTerrain::NormaliseHeightMap()
{
	for(unsigned int j = 0; j < m_height; j++)
		for(unsigned int i = 0; i < m_width; i++)
			m_heightMap[(m_height * j) + i].pos.y /= 15.0f;
}

/*
*******************************************************************
* METHOD: Render
*******************************************************************
* Calls the private RenderBuffers interface 
*
* @param ID3D11DeviceContext* - ptr to the device context we are working with
*/

void ASTerrain::Render(ID3D11DeviceContext* deviceCtxt)
{
	RenderBuffers(deviceCtxt);
}

/*
*******************************************************************
* METHOD: Render Buffers
*******************************************************************
* Send the buffers to the graphics pipe line to be drawn to the 
* scene, the drawing is handled in ASEngine 
*
* @param ID3D11DeviceContext* - ptr to the device we are using to render
*/

void ASTerrain::RenderBuffers(ID3D11DeviceContext* deviceCtxt)
{
	// Describe how the buffers are to be mapped in device mem
	unsigned int stride = sizeof(ASVertex);
	unsigned int offset = 0;

	// Send the vertex and index buffers to the device
	deviceCtxt->IASetVertexBuffers(0, 1, &m_vBuffer, &stride, &offset);
	deviceCtxt->IASetIndexBuffer(m_iBuffer, DXGI_FORMAT_R32_UINT,0);

	// Set the render format for the terrain
	deviceCtxt->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

/*
*******************************************************************
* METHOD: Get Indices
*******************************************************************
* Returns the number of indices in the terrain mesh
*/

int ASTerrain::GetNumIndices()
{
	return m_numIndices;
}

/*
*******************************************************************
* METHOD: Get Vertices
*******************************************************************
* Returns the number of vertices in the terrain mesh
*/

int ASTerrain::GetNumVertices()
{
	return m_numVertices;
}

/*
*******************************************************************
* METHOD: Release
*******************************************************************
* Calls private interface disposal methods
*/

void ASTerrain::Release()
{
	ReleaseBuffers();
	ReleaseHeightMap();
}

/*
*******************************************************************
* METHOD: Release Height Map
*******************************************************************
* Disposes of the heightmap struct safely
*/

void ASTerrain::ReleaseHeightMap()
{
	// Dispose of the height map
	if(m_heightMap)
	{
		delete [] m_heightMap;
		m_heightMap = 0;
	}
}

/*
*******************************************************************
* METHOD: Release Buffers
*******************************************************************
* Disposes of the buffers safely
*/

void ASTerrain::ReleaseBuffers()
{
	// Dispose of the index buffer
	if(m_iBuffer)
	{
		m_iBuffer->Release();
		m_iBuffer = 0;
	}
	// Dispose of the vertex buffer
	if(m_vBuffer)
	{
		m_vBuffer->Release();
		m_vBuffer = 0;
	}
}
